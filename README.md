# üîî Multi-Channel Notification Management System

## Architecture Logicielle - Projet Acad√©mique

**√âtudiant:** Mahmoud BELAYEB  
**Email:** mahmoud.belayeb@tek-up.de  
**Module:** Architecture Logicielle  
**Date:** Octobre 2025  
**√âtablissement:** TEK-UP University

[![Java](https://img.shields.io/badge/Java-17-orange)](https://www.oracle.com/java/)
[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.2.0-brightgreen)](https://spring.io/projects/spring-boot)
[![License](https://img.shields.io/badge/License-MIT-blue)](LICENSE)

---

## üìã Table des Mati√®res

1. [Pr√©sentation du Projet](#-pr√©sentation-du-projet)
2. [Style Architectural](#-style-architectural)
3. [Diagramme de Classes](#-diagramme-de-classes)
4. [Diagramme de Packages](#-diagramme-de-packages)
5. [Design Patterns Impl√©ment√©s](#-design-patterns-impl√©ment√©s)
6. [Principes SOLID](#-principes-solid)
7. [Technologies Utilis√©es](#-technologies-utilis√©es)
8. [Installation et Configuration](#-installation-et-configuration)
9. [API Documentation](#-api-documentation)
10. [Tests et D√©monstration](#-tests-et-d√©monstration)

---

## üéØ Pr√©sentation du Projet

### Description

Syst√®me complet de gestion de notifications multi-canal permettant l'envoi de messages via **Email**, **SMS** et **Push Notifications**. Le projet applique les meilleures pratiques architecturales, les design patterns du Gang of Four (GoF), et respecte rigoureusement les principes SOLID.

### Objectifs P√©dagogiques

- ‚úÖ Concevoir et impl√©menter une **architecture en couches** (Layered Architecture)
- ‚úÖ Appliquer **deux design patterns GoF** :
  - **Chain of Responsibility** pour le routage des notifications
  - **Flyweight** pour l'optimisation m√©moire
- ‚úÖ Respecter les **5 principes SOLID**
- ‚úÖ Produire des **diagrammes UML** clairs et coh√©rents
- ‚úÖ D√©velopper une application fonctionnelle avec tests r√©els

### Fonctionnalit√©s Principales

#### üìß Multi-Canal
- **Email** : Envoi via SMTP (Gmail) avec support HTML
- **SMS** : Envoi via API Twilio
- **Push** : Notifications via Firebase Cloud Messaging

#### üé® Gestion des Templates
- Templates r√©utilisables (Welcome, Order Confirmation, Password Reset, etc.)
- Personnalisation dynamique avec variables
- Cache intelligent pour optimisation m√©moire (Pattern Flyweight)

#### üîÑ Routage Automatique
- S√©lection automatique du canal via Chain of Responsibility
- Gestion intelligente des erreurs
- M√©canisme de retry automatique

#### üìä API REST
- Endpoints RESTful pour toutes les op√©rations
- Documentation interactive (Swagger/OpenAPI)
- Statistiques en temps r√©el

---

## üèóÔ∏è Style Architectural

### Architecture en Couches (Layered Architecture)

Le projet adopte une **architecture en couches** stricte, organisant le code en 4 couches distinctes avec des responsabilit√©s clairement d√©finies.


capture architecture


### Justification Architecturale

#### 1. S√©paration des Responsabilit√©s (Separation of Concerns)

Chaque couche a un r√¥le unique et bien d√©fini :

- **Presentation** : G√®re uniquement la communication HTTP/REST
- **Business** : Contient toute la logique m√©tier
- **Persistence** : Responsable de l'acc√®s aux donn√©es
- **Infrastructure** : Isole les d√©pendances externes

**Avantage** : Modifications localis√©es sans impact sur les autres couches.

#### 2. Principe de D√©pendance Unidirectionnelle

Presentation ‚Üí Business ‚Üí Persistence ‚Üí Infrastructure


Les d√©pendances vont uniquement vers le bas. Aucune couche inf√©rieure ne conna√Æt les couches sup√©rieures.

**Avantage** : Couplage faible, testabilit√© maximale.

#### 3. Inversion de D√©pendances (Dependency Inversion)

Les couches sup√©rieures d√©pendent d'**abstractions** (interfaces), pas d'impl√©mentations concr√®tes.

```java
public class NotificationService {
private final NotificationRepository repository; // Interface
private final EmailService emailService; // Interface
private final MessageTemplateFactory templateFactory; // Abstraction
}
```


**Avantage** : Changement d'impl√©mentation transparent (MySQL ‚Üí PostgreSQL, Gmail ‚Üí SendGrid).

#### 4. Maintenabilit√© et √âvolutivit√©

- **Ajout de nouveaux canaux** : Cr√©er un handler dans Business Layer
- **Changement de base de donn√©es** : Modifier uniquement Persistence Layer
- **Nouvelle API REST** : Ajouter un controller dans Presentation Layer
- **Service externe diff√©rent** : Remplacer dans Infrastructure Layer

#### 5. R√®gles Architecturales Strictes

‚úÖ **R√®gle 1** : Presentation ne peut PAS acc√©der directement √† Persistence  
‚úÖ **R√®gle 2** : Business ne peut PAS acc√©der directement √† Infrastructure  
‚úÖ **R√®gle 3** : Toutes les communications passent par des interfaces  
‚úÖ **R√®gle 4** : Aucun skip de couche autoris√©  

---

## üìä Diagramme de Classes

### Vue d'Ensemble Compl√®te

Capture class diagram


### Relations Entre Classes

#### Pattern Chain of Responsibility
- `NotificationHandler` (interface) ‚Üê impl√©ment√©e par `BaseNotificationHandler`
- `BaseNotificationHandler` ‚Üê √©tendue par `EmailHandler`, `SMSHandler`, `PushHandler`
- `NotificationChainBuilder` cr√©e et configure la cha√Æne

#### Pattern Flyweight
- `MessageTemplateFactory` cr√©e et met en cache les `MessageTemplate`
- `MessageTemplate` contient l'√©tat intrins√®que (pattern, format)
- Les donn√©es extrins√®ques (userName, etc.) sont pass√©es en param√®tre

---

## üì¶ Diagramme de Packages

### Structure Compl√®te des Packages

capture package diagram


### Justification de la R√©partition

#### Package Presentation
**Responsabilit√©** : Interface avec le monde ext√©rieur  
**Contenu** : Controllers REST, DTOs, Validation  
**Pourquoi** : Isoler la couche de pr√©sentation permet de changer l'interface (REST ‚Üí GraphQL ‚Üí gRPC) sans impacter le m√©tier

#### Package Business
**Responsabilit√©** : Logique m√©tier et patterns  
**Contenu** : Services, handlers (Chain of Responsibility), templates (Flyweight)  
**Pourquoi** : C≈ìur de l'application, totalement ind√©pendant de l'infrastructure technique

#### Package Persistence
**Responsabilit√©** : Acc√®s et stockage des donn√©es  
**Contenu** : Entities JPA, Repositories, Mappers  
**Pourquoi** : Facilite le changement de base de donn√©es ou de technologie de persistence

#### Package Infrastructure
**Responsabilit√©** : Services externes et techniques  
**Contenu** : Impl√©mentations concr√®tes (Email, SMS, Push)  
**Pourquoi** : D√©couple les fournisseurs externes (Gmail ‚Üí SendGrid, Twilio ‚Üí AWS SNS, etc.)

#### Package Common
**Responsabilit√©** : √âl√©ments r√©utilisables  
**Contenu** : Configuration, exceptions, enums, utilitaires  
**Pourquoi** : √âviter la duplication de code √† travers les couches

### Flux de Donn√©es
Client HTTP Request
‚Üì
NotificationController (Presentation)
‚Üì [DTO ‚Üí Model]
NotificationService (Business)
‚Üì [Uses Chain]
EmailHandler/SMSHandler/PushHandler (Business)
‚Üì [Uses Infrastructure]
EmailService/SMSService/PushService (Infrastructure)
‚Üì [Saves to DB]
NotificationRepository (Persistence)
‚Üì
Database (MySQL)


---

## üé® Design Patterns Impl√©ment√©s

### 1. Chain of Responsibility (Cha√Æne de Responsabilit√©)

#### Probl√®me R√©solu

Sans ce pattern, le code ressemblerait √† ceci :

```java
// ‚ùå APPROCHE PROBL√âMATIQUE - Couplage Fort
public class NotificationService {
public void sendNotification(Notification notification) {
if (notification.getChannel() == Channel.EMAIL) {
emailService.sendEmail(notification.getRecipient(),
notification.getSubject(),
notification.getMessage());
} else if (notification.getChannel() == Channel.SMS) {
smsService.sendSMS(notification.getRecipient(),
notification.getMessage());
} else if (notification.getChannel() == Channel.PUSH) {
pushService.sendPush(notification.getRecipient(),
notification.getSubject(),
notification.getMessage());
}
// Pour ajouter WhatsApp, il faut MODIFIER cette m√©thode
// Violation du principe Open/Closed !
}
}
```
**Probl√®mes identifi√©s :**
- ‚ùå Violation du principe **Open/Closed** (ajout = modification)
- ‚ùå **Couplage fort** entre le service et les impl√©mentations
- ‚ùå Logique de routage **m√©lang√©e** avec la logique m√©tier
- ‚ùå Difficile √† **tester** unitairement
- ‚ùå Impossible d'ajouter de nouveaux canaux sans modifier le code existant

#### Solution avec Chain of Responsibility

##### Structure du Pattern

```java
// 1. INTERFACE - Contrat commun
public interface NotificationHandler {
void setNext(NotificationHandler handler);
void handle(Notification notification);
}

// 2. CLASSE ABSTRAITE - Logique commune de cha√Ænage
@Slf4j
public abstract class BaseNotificationHandler implements NotificationHandler {
protected NotificationHandler next;
protected final String handlerName;

protected BaseNotificationHandler(String handlerName) {
    this.handlerName = handlerName;
}

@Override
public void setNext(NotificationHandler handler) {
    this.next = handler;
    log.info("üîó {} ‚Üí cha√Æn√© avec {}", 
            this.handlerName, 
            ((BaseNotificationHandler)handler).handlerName);
}

@Override
public void handle(Notification notification) {
    log.info("üîç {} re√ßoit la notification", handlerName);
    
    if (canHandle(notification)) {
        log.info("‚úÖ {} PEUT traiter cette notification!", handlerName);
        process(notification);
    } else {
        log.info("‚ùå {} ne peut PAS traiter le canal {}", 
                handlerName, notification.getChannel());
        passToNext(notification);
    }
}

protected void passToNext(Notification notification) {
    if (next != null) {
        log.info("‚è≠Ô∏è  Passage √† {} ‚Üí", 
                ((BaseNotificationHandler)next).handlerName);
        next.handle(notification);
    } else {
        log.warn("‚õî Fin de cha√Æne atteinte. Aucun handler disponible.");
    }
}

// M√©thodes abstraites √† impl√©menter par les handlers concrets
protected abstract boolean canHandle(Notification notification);
protected abstract void process(Notification notification);
}

// 3. HANDLER CONCRET - Email
@Component
@RequiredArgsConstructor
public class EmailHandler extends BaseNotificationHandler {
private final EmailService emailService;

public EmailHandler(EmailService emailService) {
    super("üìß EmailHandler");
    this.emailService = emailService;
}

@Override
protected boolean canHandle(Notification notification) {
    return notification.getChannel() == Channel.EMAIL;
}

@Override
protected void process(Notification notification) {
    emailService.sendEmail(
        notification.getRecipient(),
        notification.getSubject(),
        notification.getMessage()
    );
    log.info("‚úÖ Email envoy√© avec succ√®s!");
}
}

// 4. BUILDER - Construction de la cha√Æne
@Component
@RequiredArgsConstructor
public class NotificationChainBuilder {
private final EmailHandler emailHandler;
private final SMSHandler smsHandler;
private final PushHandler pushHandler;

public NotificationHandler buildChain() {
    log.info("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    log.info("‚ïë   CONSTRUCTION DE LA CHA√éNE            ‚ïë");
    log.info("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
    
    // Construire la cha√Æne: Email ‚Üí SMS ‚Üí Push
    emailHandler.setNext(smsHandler);
    smsHandler.setNext(pushHandler);
    
    log.info("‚úÖ Cha√Æne construite: üìß Email ‚Üí üì± SMS ‚Üí üîî Push");
    
    return emailHandler; // Retourner le premier maillon
}
}
```






